<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#0d1b2a">
    <title>üêç ÏßÄÎ†ÅÏù¥</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body {
            width: 100%; height: 100%;
            overflow: hidden;
            background: linear-gradient(135deg, #0d1b2a 0%, #1b263b 100%);
            touch-action: none;
            user-select: none;
        }
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        .header {
            position: absolute;
            top: 20px;
            display: flex;
            gap: 30px;
            color: #fff;
            font-family: 'Segoe UI', sans-serif;
            font-size: 18px;
            z-index: 10;
        }
        .header span { color: #00d4ff; font-weight: bold; }
        #gameCanvas {
            border-radius: 15px;
            box-shadow: 0 0 40px rgba(0,212,255,0.2);
        }
    </style>
</head>
<body>
    <div class="header">
        <div>üçé <span id="score">0</span></div>
        <div>üèÜ <span id="best">0</span></div>
    </div>
    <canvas id="gameCanvas"></canvas>

    <script src="../framework/game-wrapper.js"></script>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        const GRID = 20;
        let COLS, ROWS, CELL;
        let snake = [], direction = {x:1,y:0}, nextDirection = {x:1,y:0};
        let food = {x:0,y:0}, specialFood = null;
        let score = 0, best = parseInt(localStorage.getItem('snakeBest'))||0;
        let gameRunning = false, speed = 150, lastTime = 0;

        const COLORS = {
            head: '#00d4ff', body: '#0099cc', bodyAlt: '#007799',
            food: '#ff6b6b', special: '#ffd93d', grid: 'rgba(255,255,255,0.03)'
        };

        function resizeCanvas() {
            // PCÏóêÏÑúÎäî Îçî ÌÅ¨Í≤å
            const maxLimit = window.innerWidth > 768 ? 700 : 500;
            const maxSize = Math.min(window.innerWidth - 30, window.innerHeight - 100, maxLimit);
            CELL = Math.floor(maxSize / GRID);
            COLS = ROWS = GRID;
            canvas.width = COLS * CELL;
            canvas.height = ROWS * CELL;
        }

        function initGame() {
            const startX = Math.floor(COLS / 2);
            const startY = Math.floor(ROWS / 2);
            snake = [{x:startX,y:startY},{x:startX-1,y:startY},{x:startX-2,y:startY}];
            direction = {x:1,y:0}; nextDirection = {x:1,y:0};
            score = 0; speed = 150; specialFood = null;
            spawnFood(); updateScore();
        }

        function spawnFood() {
            let valid = false;
            while (!valid) {
                food.x = Math.floor(Math.random() * COLS);
                food.y = Math.floor(Math.random() * ROWS);
                valid = !snake.some(s => s.x === food.x && s.y === food.y);
            }
            if (Math.random() < 0.1 && !specialFood) {
                let pos;
                do {
                    pos = {x:Math.floor(Math.random()*COLS),y:Math.floor(Math.random()*ROWS),timer:100};
                } while (snake.some(s=>s.x===pos.x&&s.y===pos.y)||(pos.x===food.x&&pos.y===food.y));
                specialFood = pos;
            }
        }

        function move() {
            direction = {...nextDirection};
            const head = {x:snake[0].x+direction.x, y:snake[0].y+direction.y};
            if (head.x<0||head.x>=COLS||head.y<0||head.y>=ROWS) return endGame();
            if (snake.some(s=>s.x===head.x&&s.y===head.y)) return endGame();
            snake.unshift(head);
            if (head.x===food.x&&head.y===food.y) {
                score+=10; speed=Math.max(50,speed-2); spawnFood(); updateScore();
            } else if (specialFood&&head.x===specialFood.x&&head.y===specialFood.y) {
                score+=50; specialFood=null; updateScore();
            } else { snake.pop(); }
            if (specialFood) { specialFood.timer--; if(specialFood.timer<=0) specialFood=null; }
        }

        function draw() {
            ctx.fillStyle = '#0d1b2a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.strokeStyle = COLORS.grid; ctx.lineWidth = 1;
            for (let x=0;x<=COLS;x++) { ctx.beginPath(); ctx.moveTo(x*CELL,0); ctx.lineTo(x*CELL,canvas.height); ctx.stroke(); }
            for (let y=0;y<=ROWS;y++) { ctx.beginPath(); ctx.moveTo(0,y*CELL); ctx.lineTo(canvas.width,y*CELL); ctx.stroke(); }
            
            ctx.font = `${CELL-4}px Arial`; ctx.textAlign='center'; ctx.textBaseline='middle';
            ctx.fillText('üçé', food.x*CELL+CELL/2, food.y*CELL+CELL/2+2);
            if (specialFood) {
                ctx.globalAlpha = specialFood.timer<30 ? 0.3+0.7*Math.abs(Math.sin(Date.now()/50)) : 1;
                ctx.fillText('‚≠ê', specialFood.x*CELL+CELL/2, specialFood.y*CELL+CELL/2+2);
                ctx.globalAlpha = 1;
            }

            snake.forEach((seg,i) => {
                const isHead = i===0;
                ctx.fillStyle = isHead ? COLORS.head : (i%2===0 ? COLORS.body : COLORS.bodyAlt);
                if(isHead) { ctx.shadowColor=COLORS.head; ctx.shadowBlur=15; }
                else ctx.shadowBlur=0;
                const pad = isHead?1:2, size=CELL-pad*2, r=isHead?size/2:size/3;
                ctx.beginPath();
                ctx.roundRect(seg.x*CELL+pad, seg.y*CELL+pad, size, size, r);
                ctx.fill();
                if(isHead) {
                    ctx.shadowBlur=0; ctx.fillStyle='#fff';
                    const es=CELL/6, eo=CELL/4;
                    let e1x,e1y,e2x,e2y;
                    if(direction.x===1){e1x=seg.x*CELL+CELL-eo;e1y=seg.y*CELL+eo;e2x=e1x;e2y=seg.y*CELL+CELL-eo;}
                    else if(direction.x===-1){e1x=seg.x*CELL+eo;e1y=seg.y*CELL+eo;e2x=e1x;e2y=seg.y*CELL+CELL-eo;}
                    else if(direction.y===-1){e1x=seg.x*CELL+eo;e1y=seg.y*CELL+eo;e2x=seg.x*CELL+CELL-eo;e2y=e1y;}
                    else{e1x=seg.x*CELL+eo;e1y=seg.y*CELL+CELL-eo;e2x=seg.x*CELL+CELL-eo;e2y=e1y;}
                    ctx.beginPath(); ctx.arc(e1x,e1y,es,0,Math.PI*2); ctx.arc(e2x,e2y,es,0,Math.PI*2); ctx.fill();
                }
            });
            ctx.shadowBlur=0;
        }

        function updateScore() {
            document.getElementById('score').textContent = score;
            document.getElementById('best').textContent = best;
        }

        function gameLoop(time) {
            if (!gameRunning) return;
            if (time - lastTime > speed) { move(); lastTime = time; }
            draw();
            requestAnimationFrame(gameLoop);
        }

        function endGame() {
            gameRunning = false;
            if (score > best) { best = score; localStorage.setItem('snakeBest', best); }
            window.gameOver(score);
        }

        function changeDirection(dir) {
            if (!gameRunning) return;
            const opp = {up:'down',down:'up',left:'right',right:'left'};
            const cur = direction.y===-1?'up':direction.y===1?'down':direction.x===-1?'left':'right';
            if (opp[dir]===cur) return;
            switch(dir) {
                case 'up': nextDirection={x:0,y:-1}; break;
                case 'down': nextDirection={x:0,y:1}; break;
                case 'left': nextDirection={x:-1,y:0}; break;
                case 'right': nextDirection={x:1,y:0}; break;
            }
        }

        document.addEventListener('keydown', e => {
            switch(e.code) {
                case 'ArrowUp': case 'KeyW': e.preventDefault(); changeDirection('up'); break;
                case 'ArrowDown': case 'KeyS': e.preventDefault(); changeDirection('down'); break;
                case 'ArrowLeft': case 'KeyA': e.preventDefault(); changeDirection('left'); break;
                case 'ArrowRight': case 'KeyD': e.preventDefault(); changeDirection('right'); break;
            }
        });

        let touchStartX=0, touchStartY=0;
        document.addEventListener('touchstart', e => { touchStartX=e.touches[0].clientX; touchStartY=e.touches[0].clientY; }, {passive:true});
        document.addEventListener('touchend', e => {
            const dx=e.changedTouches[0].clientX-touchStartX, dy=e.changedTouches[0].clientY-touchStartY;
            if (Math.max(Math.abs(dx),Math.abs(dy)) < 30) return;
            if (Math.abs(dx)>Math.abs(dy)) changeDirection(dx>0?'right':'left');
            else changeDirection(dy>0?'down':'up');
        }, {passive:true});

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // Í≤åÏûÑ Îì±Î°ù
        window.GAME = {
            name: 'ÏßÄÎ†ÅÏù¥',
            emoji: 'üêç',
            image: '../assets/character-snake.svg',
            start: () => { gameRunning = true; lastTime = performance.now(); requestAnimationFrame(gameLoop); },
            reset: () => { initGame(); draw(); },
            stop: () => { gameRunning = false; }
        };
        initGame(); draw();
    </script>
</body>
</html>
