<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#1a1a2e">
    <title>üçâ Fruit Ninja</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body {
            width: 100%; height: 100%;
            overflow: hidden;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            touch-action: none;
            user-select: none;
        }
        body { display: flex; align-items: center; justify-content: center; }
        canvas { border-radius: 12px; box-shadow: 0 4px 20px rgba(0,0,0,0.3); }
    </style>
</head>
<body>
    <canvas id="game"></canvas>
    <script>
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');

        const isPC = window.innerWidth > 768;
        const BASE_WIDTH = isPC ? 450 : 360;
        const BASE_HEIGHT = isPC ? 700 : 640;
        let scale = 1, dpr = 1;

        function resizeCanvas() {
            dpr = Math.min(window.devicePixelRatio || 1, 2);
            const wW = window.innerWidth, wH = window.innerHeight;
            const ratio = BASE_WIDTH / BASE_HEIGHT;
            let dW, dH;
            if (wW/wH > ratio) { dH = Math.min(wH*0.95, BASE_HEIGHT*1.5); dW = dH*ratio; }
            else { dW = Math.min(wW*0.95, BASE_WIDTH*1.5); dH = dW/ratio; }
            canvas.style.width = dW+'px'; canvas.style.height = dH+'px';
            canvas.width = dW*dpr; canvas.height = dH*dpr;
            scale = (dW/BASE_WIDTH)*dpr;
            ctx.setTransform(scale,0,0,scale,0,0);
        }

        // Í≤åÏûÑ ÏÉÅÌÉú
        let gameState = 'ready'; // ready, playing, gameover
        let score = 0;
        let bestScore = localStorage.getItem('fruitninjaBest') || 0;
        let lives = 3;
        let combo = 0;
        let maxCombo = 0;
        let comboTimer = 0;

        // Í≥ºÏùº Ï¢ÖÎ•ò
        const FRUITS = [
            { name: 'watermelon', emoji: 'üçâ', color: '#e74c3c', points: 1 },
            { name: 'orange', emoji: 'üçä', color: '#f39c12', points: 1 },
            { name: 'apple', emoji: 'üçé', color: '#c0392b', points: 1 },
            { name: 'banana', emoji: 'üçå', color: '#f1c40f', points: 1 },
            { name: 'grape', emoji: 'üçá', color: '#9b59b6', points: 2 },
            { name: 'peach', emoji: 'üçë', color: '#fd79a8', points: 1 },
            { name: 'pineapple', emoji: 'üçç', color: '#f39c12', points: 2 },
            { name: 'strawberry', emoji: 'üçì', color: '#e74c3c', points: 1 },
            { name: 'kiwi', emoji: 'ü•ù', color: '#27ae60', points: 2 },
            { name: 'bomb', emoji: 'üí£', color: '#2c3e50', points: -10, isBomb: true }
        ];

        // Í≤åÏûÑ Ïò§Î∏åÏ†ùÌä∏
        let fruits = [];
        let slices = [];
        let particles = [];
        let slashTrail = [];

        // Í≥ºÏùº Ïä§Ìè∞ ÏÑ§Ï†ï
        let spawnTimer = 0;
        let spawnInterval = 60;
        let difficultyTimer = 0;

        // Ïä¨ÎûòÏãú Í¥ÄÎ†®
        let isSlashing = false;
        let lastSlashPos = null;

        // Í≥ºÏùº ÏÉùÏÑ±
        function spawnFruit() {
            const fruitType = FRUITS[Math.floor(Math.random() * FRUITS.length)];
            const x = 50 + Math.random() * (BASE_WIDTH - 100);
            const vx = (Math.random() - 0.5) * 6;
            const vy = -15 - Math.random() * 5;
            
            fruits.push({
                ...fruitType,
                x: x,
                y: BASE_HEIGHT + 40,
                vx: vx,
                vy: vy,
                rotation: 0,
                rotationSpeed: (Math.random() - 0.5) * 0.3,
                radius: 30 + Math.random() * 10,
                sliced: false
            });
        }

        // Í≥ºÏùº Ïä¨ÎùºÏù¥Ïä§
        function sliceFruit(fruit, slashAngle) {
            if (fruit.sliced) return;
            fruit.sliced = true;

            if (fruit.isBomb) {
                // Ìè≠ÌÉÑ ÌÑ∞Ïßê
                gameState = 'gameover';
                createExplosion(fruit.x, fruit.y, '#ff0000');
                if (navigator.vibrate) navigator.vibrate(200);
                return;
            }

            // Ï†êÏàò Ï∂îÍ∞Ä
            combo++;
            comboTimer = 30;
            if (combo > maxCombo) maxCombo = combo;
            
            const comboBonus = Math.floor(combo / 3);
            score += fruit.points + comboBonus;

            // Ïä¨ÎùºÏù¥Ïä§ Ï°∞Í∞Å ÏÉùÏÑ±
            for (let i = 0; i < 2; i++) {
                slices.push({
                    x: fruit.x,
                    y: fruit.y,
                    vx: (i === 0 ? -3 : 3) + Math.random() * 2,
                    vy: -5 + Math.random() * 3,
                    rotation: fruit.rotation,
                    rotationSpeed: (Math.random() - 0.5) * 0.5,
                    radius: fruit.radius * 0.6,
                    color: fruit.color,
                    emoji: fruit.emoji,
                    alpha: 1,
                    half: i
                });
            }

            // ÌååÌã∞ÌÅ¥
            createJuiceParticles(fruit.x, fruit.y, fruit.color);
            
            if (navigator.vibrate) navigator.vibrate(30);
        }

        // Ï£ºÏä§ ÌååÌã∞ÌÅ¥
        function createJuiceParticles(x, y, color) {
            for (let i = 0; i < 12; i++) {
                const angle = (Math.PI * 2 / 12) * i + Math.random() * 0.5;
                const speed = 3 + Math.random() * 5;
                particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    radius: 3 + Math.random() * 4,
                    color: color,
                    alpha: 1,
                    gravity: 0.15
                });
            }
        }

        // Ìè≠Î∞ú Ïù¥ÌéôÌä∏
        function createExplosion(x, y, color) {
            for (let i = 0; i < 30; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 5 + Math.random() * 10;
                particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    radius: 5 + Math.random() * 8,
                    color: i % 2 === 0 ? '#ff6b6b' : '#ffa502',
                    alpha: 1,
                    gravity: 0.1
                });
            }
        }

        // Ïä¨ÎûòÏãú Ï≤¥ÌÅ¨
        function checkSlash(x, y) {
            if (!isSlashing || !lastSlashPos) return;

            // Ïä¨ÎûòÏãú Ìä∏Î†àÏùº Ï∂îÍ∞Ä
            slashTrail.push({
                x: x,
                y: y,
                alpha: 1
            });

            // Í≥ºÏùº Ï∂©Îèå Ï≤¥ÌÅ¨
            fruits.forEach(fruit => {
                if (fruit.sliced) return;
                const dx = fruit.x - x;
                const dy = fruit.y - y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                
                if (dist < fruit.radius + 15) {
                    const angle = Math.atan2(y - lastSlashPos.y, x - lastSlashPos.x);
                    sliceFruit(fruit, angle);
                }
            });

            lastSlashPos = { x, y };
        }

        // ÏûÖÎ†• Ï≤òÎ¶¨
        function getPos(e) {
            const rect = canvas.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            return {
                x: (clientX - rect.left) / (rect.width / BASE_WIDTH),
                y: (clientY - rect.top) / (rect.height / BASE_HEIGHT)
            };
        }

        canvas.addEventListener('mousedown', (e) => {
            if (gameState === 'ready') {
                startGame();
                return;
            }
            if (gameState === 'gameover') {
                resetGame();
                return;
            }
            isSlashing = true;
            lastSlashPos = getPos(e);
        });

        canvas.addEventListener('mousemove', (e) => {
            if (gameState !== 'playing') return;
            const pos = getPos(e);
            checkSlash(pos.x, pos.y);
        });

        canvas.addEventListener('mouseup', () => {
            isSlashing = false;
            lastSlashPos = null;
        });

        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (gameState === 'ready') {
                startGame();
                return;
            }
            if (gameState === 'gameover') {
                resetGame();
                return;
            }
            isSlashing = true;
            lastSlashPos = getPos(e);
        }, { passive: false });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (gameState !== 'playing') return;
            const pos = getPos(e);
            checkSlash(pos.x, pos.y);
        }, { passive: false });

        canvas.addEventListener('touchend', () => {
            isSlashing = false;
            lastSlashPos = null;
        });

        // Í≤åÏûÑ ÏãúÏûë
        function startGame() {
            gameState = 'playing';
            score = 0;
            lives = 3;
            combo = 0;
            maxCombo = 0;
            fruits = [];
            slices = [];
            particles = [];
            spawnTimer = 0;
            spawnInterval = 80;
            difficultyTimer = 0;
        }

        // Í≤åÏûÑ Î¶¨ÏÖã
        function resetGame() {
            if (score > bestScore) {
                bestScore = score;
                localStorage.setItem('fruitninjaBest', bestScore);
            }
            gameState = 'ready';
        }

        // ÏóÖÎç∞Ïù¥Ìä∏
        function update() {
            if (gameState !== 'playing') return;

            // ÎÇúÏù¥ÎèÑ Ï¶ùÍ∞Ä
            difficultyTimer++;
            if (difficultyTimer % 600 === 0 && spawnInterval > 30) {
                spawnInterval -= 5;
            }

            // Í≥ºÏùº Ïä§Ìè∞
            spawnTimer++;
            if (spawnTimer >= spawnInterval) {
                spawnTimer = 0;
                const count = 1 + Math.floor(Math.random() * (difficultyTimer > 1200 ? 3 : 2));
                for (let i = 0; i < count; i++) {
                    setTimeout(() => spawnFruit(), i * 150);
                }
            }

            // ÏΩ§Î≥¥ ÌÉÄÏù¥Î®∏
            if (comboTimer > 0) {
                comboTimer--;
                if (comboTimer === 0) combo = 0;
            }

            // Í≥ºÏùº ÏóÖÎç∞Ïù¥Ìä∏
            fruits = fruits.filter(fruit => {
                fruit.vy += 0.4; // Ï§ëÎ†•
                fruit.x += fruit.vx;
                fruit.y += fruit.vy;
                fruit.rotation += fruit.rotationSpeed;

                // ÌôîÎ©¥ Î∞ñ (ÎÜìÏπú Í≥ºÏùº)
                if (fruit.y > BASE_HEIGHT + 60 && !fruit.sliced && !fruit.isBomb) {
                    lives--;
                    if (navigator.vibrate) navigator.vibrate(100);
                    if (lives <= 0) {
                        gameState = 'gameover';
                    }
                    return false;
                }

                return fruit.y < BASE_HEIGHT + 100 && !fruit.sliced;
            });

            // Ïä¨ÎùºÏù¥Ïä§ Ï°∞Í∞Å ÏóÖÎç∞Ïù¥Ìä∏
            slices = slices.filter(slice => {
                slice.vy += 0.5;
                slice.x += slice.vx;
                slice.y += slice.vy;
                slice.rotation += slice.rotationSpeed;
                slice.alpha -= 0.015;
                return slice.alpha > 0;
            });

            // ÌååÌã∞ÌÅ¥ ÏóÖÎç∞Ïù¥Ìä∏
            particles = particles.filter(p => {
                p.vy += p.gravity;
                p.x += p.vx;
                p.y += p.vy;
                p.alpha -= 0.025;
                return p.alpha > 0;
            });

            // Ïä¨ÎûòÏãú Ìä∏Î†àÏùº ÏóÖÎç∞Ïù¥Ìä∏
            slashTrail = slashTrail.filter(t => {
                t.alpha -= 0.1;
                return t.alpha > 0;
            });
        }

        // Î†åÎçîÎßÅ
        function draw() {
            // Î∞∞Í≤Ω
            const bgGrad = ctx.createLinearGradient(0, 0, 0, BASE_HEIGHT);
            bgGrad.addColorStop(0, '#1a1a2e');
            bgGrad.addColorStop(1, '#16213e');
            ctx.fillStyle = bgGrad;
            ctx.fillRect(0, 0, BASE_WIDTH, BASE_HEIGHT);

            // Î∞∞Í≤Ω Ïû•Ïãù
            ctx.save();
            ctx.globalAlpha = 0.05;
            ctx.font = '80px serif';
            ctx.textAlign = 'center';
            ctx.fillStyle = '#fff';
            ctx.fillText('üçâ', BASE_WIDTH * 0.2, BASE_HEIGHT * 0.3);
            ctx.fillText('üçä', BASE_WIDTH * 0.8, BASE_HEIGHT * 0.5);
            ctx.fillText('üçé', BASE_WIDTH * 0.3, BASE_HEIGHT * 0.7);
            ctx.restore();

            if (gameState === 'ready') {
                drawReadyScreen();
                return;
            }

            if (gameState === 'gameover') {
                drawGameOverScreen();
                return;
            }

            // Ïä¨ÎûòÏãú Ìä∏Î†àÏùº
            if (slashTrail.length > 1) {
                ctx.save();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 4;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.beginPath();
                slashTrail.forEach((t, i) => {
                    ctx.globalAlpha = t.alpha * 0.8;
                    if (i === 0) ctx.moveTo(t.x, t.y);
                    else ctx.lineTo(t.x, t.y);
                });
                ctx.stroke();
                ctx.restore();
            }

            // ÌååÌã∞ÌÅ¥
            particles.forEach(p => {
                ctx.save();
                ctx.globalAlpha = p.alpha;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            });

            // Í≥ºÏùº
            fruits.forEach(fruit => {
                ctx.save();
                ctx.translate(fruit.x, fruit.y);
                ctx.rotate(fruit.rotation);
                ctx.font = `${fruit.radius * 1.8}px serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(fruit.emoji, 0, 0);
                ctx.restore();
            });

            // Ïä¨ÎùºÏù¥Ïä§ Ï°∞Í∞Å
            slices.forEach(slice => {
                ctx.save();
                ctx.globalAlpha = slice.alpha;
                ctx.translate(slice.x, slice.y);
                ctx.rotate(slice.rotation);
                
                // Î∞òÏ™Ω ÌÅ¥Î¶¨Ìïë
                ctx.beginPath();
                if (slice.half === 0) {
                    ctx.rect(-slice.radius * 2, -slice.radius * 2, slice.radius * 2, slice.radius * 4);
                } else {
                    ctx.rect(0, -slice.radius * 2, slice.radius * 2, slice.radius * 4);
                }
                ctx.clip();
                
                ctx.font = `${slice.radius * 2.5}px serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(slice.emoji, 0, 0);
                ctx.restore();
            });

            // UI
            drawUI();
        }

        function drawReadyScreen() {
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 48px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('üçâ Fruit Ninja', BASE_WIDTH/2, BASE_HEIGHT * 0.35);

            ctx.font = '24px sans-serif';
            ctx.fillStyle = 'rgba(255,255,255,0.7)';
            ctx.fillText('Í≥ºÏùºÏùÑ Ïä¨ÎùºÏù¥Ïä§ÌïòÏÑ∏Ïöî!', BASE_WIDTH/2, BASE_HEIGHT * 0.45);
            ctx.fillText('üí£ Ìè≠ÌÉÑÏùÄ ÌîºÌïòÏÑ∏Ïöî!', BASE_WIDTH/2, BASE_HEIGHT * 0.52);

            ctx.font = '20px sans-serif';
            ctx.fillStyle = '#f1c40f';
            ctx.fillText(`üèÜ ÏµúÍ≥†Ï†ê: ${bestScore}`, BASE_WIDTH/2, BASE_HEIGHT * 0.65);

            // ÏãúÏûë Î≤ÑÌäº
            ctx.fillStyle = 'rgba(255,255,255,0.15)';
            roundRect(ctx, BASE_WIDTH/2 - 80, BASE_HEIGHT * 0.72, 160, 50, 25, true, false);
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 20px sans-serif';
            ctx.fillText('ÌÉ≠ÌïòÏó¨ ÏãúÏûë', BASE_WIDTH/2, BASE_HEIGHT * 0.72 + 30);
        }

        function drawGameOverScreen() {
            ctx.fillStyle = 'rgba(0,0,0,0.7)';
            ctx.fillRect(0, 0, BASE_WIDTH, BASE_HEIGHT);

            ctx.fillStyle = '#e74c3c';
            ctx.font = 'bold 42px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('GAME OVER', BASE_WIDTH/2, BASE_HEIGHT * 0.35);

            ctx.fillStyle = '#fff';
            ctx.font = '28px sans-serif';
            ctx.fillText(`Ï†êÏàò: ${score}`, BASE_WIDTH/2, BASE_HEIGHT * 0.48);

            ctx.font = '22px sans-serif';
            ctx.fillStyle = '#f39c12';
            ctx.fillText(`ÏµúÎåÄ ÏΩ§Î≥¥: ${maxCombo}x`, BASE_WIDTH/2, BASE_HEIGHT * 0.56);

            if (score > bestScore - score && score >= bestScore) {
                ctx.fillStyle = '#2ecc71';
                ctx.font = 'bold 24px sans-serif';
                ctx.fillText('üéâ ÏÉà Í∏∞Î°ù!', BASE_WIDTH/2, BASE_HEIGHT * 0.64);
            }

            ctx.fillStyle = '#f1c40f';
            ctx.font = '20px sans-serif';
            ctx.fillText(`üèÜ ÏµúÍ≥†Ï†ê: ${Math.max(score, bestScore)}`, BASE_WIDTH/2, BASE_HEIGHT * 0.72);

            // Ïû¨ÏãúÏûë Î≤ÑÌäº
            ctx.fillStyle = 'rgba(255,255,255,0.15)';
            roundRect(ctx, BASE_WIDTH/2 - 80, BASE_HEIGHT * 0.78, 160, 50, 25, true, false);
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 20px sans-serif';
            ctx.fillText('Îã§Ïãú ÏãúÏûë', BASE_WIDTH/2, BASE_HEIGHT * 0.78 + 30);
        }

        function drawUI() {
            // Ï†êÏàò
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 28px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText(`${score}`, 20, 40);

            // ÏΩ§Î≥¥
            if (combo >= 2) {
                ctx.fillStyle = '#f39c12';
                ctx.font = 'bold 22px sans-serif';
                ctx.fillText(`${combo}x COMBO!`, 20, 70);
            }

            // Î™©Ïà®
            ctx.textAlign = 'right';
            ctx.font = '24px sans-serif';
            let livesText = '';
            for (let i = 0; i < 3; i++) {
                livesText += i < lives ? '‚ùå' : '‚≠ï';
            }
            ctx.fillText(livesText, BASE_WIDTH - 20, 40);
        }

        // Îë•Í∑º ÏÇ¨Í∞ÅÌòï Ìó¨Ìçº
        function roundRect(ctx, x, y, w, h, r, fill, stroke) {
            ctx.beginPath();
            ctx.moveTo(x + r, y);
            ctx.arcTo(x + w, y, x + w, y + h, r);
            ctx.arcTo(x + w, y + h, x, y + h, r);
            ctx.arcTo(x, y + h, x, y, r);
            ctx.arcTo(x, y, x + w, y, r);
            ctx.closePath();
            if (fill) ctx.fill();
            if (stroke) ctx.stroke();
        }

        // Í≤åÏûÑ Î£®ÌîÑ
        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        // Ï¥àÍ∏∞Ìôî
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        gameLoop();
    </script>
</body>
</html>
